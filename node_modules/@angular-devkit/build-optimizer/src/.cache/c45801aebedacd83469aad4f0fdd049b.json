{"remainingRequest":"D:\\Code MWSC\\2020-MWSC-Github\\webapps\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Code MWSC\\2020-MWSC-Github\\webapps\\node_modules\\positioning\\dist\\positioning.js","dependencies":[{"path":"D:\\Code MWSC\\2020-MWSC-Github\\webapps\\node_modules\\positioning\\dist\\positioning.js","mtime":499162500000},{"path":"D:\\Code MWSC\\2020-MWSC-Github\\webapps\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1614055079483},{"path":"D:\\Code MWSC\\2020-MWSC-Github\\webapps\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\nvar Positioning = /*@__PURE__*/ (function () {\n    function Positioning() {\n    }\n    Positioning.prototype.getAllStyles = function (element) { return window.getComputedStyle(element); };\n    Positioning.prototype.getStyle = function (element, prop) { return this.getAllStyles(element)[prop]; };\n    Positioning.prototype.isStaticPositioned = function (element) {\n        return (this.getStyle(element, 'position') || 'static') === 'static';\n    };\n    Positioning.prototype.offsetParent = function (element) {\n        var offsetParentEl = element.offsetParent || document.documentElement;\n        while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n            offsetParentEl = offsetParentEl.offsetParent;\n        }\n        return offsetParentEl || document.documentElement;\n    };\n    Positioning.prototype.position = function (element, round) {\n        if (round === void 0) {\n            round = true;\n        }\n        var elPosition;\n        var parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };\n        if (this.getStyle(element, 'position') === 'fixed') {\n            elPosition = element.getBoundingClientRect();\n        }\n        else {\n            var offsetParentEl = this.offsetParent(element);\n            elPosition = this.offset(element, false);\n            if (offsetParentEl !== document.documentElement) {\n                parentOffset = this.offset(offsetParentEl, false);\n            }\n            parentOffset.top += offsetParentEl.clientTop;\n            parentOffset.left += offsetParentEl.clientLeft;\n        }\n        elPosition.top -= parentOffset.top;\n        elPosition.bottom -= parentOffset.top;\n        elPosition.left -= parentOffset.left;\n        elPosition.right -= parentOffset.left;\n        if (round) {\n            elPosition.top = Math.round(elPosition.top);\n            elPosition.bottom = Math.round(elPosition.bottom);\n            elPosition.left = Math.round(elPosition.left);\n            elPosition.right = Math.round(elPosition.right);\n        }\n        return elPosition;\n    };\n    Positioning.prototype.offset = function (element, round) {\n        if (round === void 0) {\n            round = true;\n        }\n        var elBcr = element.getBoundingClientRect();\n        var viewportOffset = {\n            top: window.pageYOffset - document.documentElement.clientTop,\n            left: window.pageXOffset - document.documentElement.clientLeft\n        };\n        var elOffset = {\n            height: elBcr.height || element.offsetHeight,\n            width: elBcr.width || element.offsetWidth,\n            top: elBcr.top + viewportOffset.top,\n            bottom: elBcr.bottom + viewportOffset.top,\n            left: elBcr.left + viewportOffset.left,\n            right: elBcr.right + viewportOffset.left\n        };\n        if (round) {\n            elOffset.height = Math.round(elOffset.height);\n            elOffset.width = Math.round(elOffset.width);\n            elOffset.top = Math.round(elOffset.top);\n            elOffset.bottom = Math.round(elOffset.bottom);\n            elOffset.left = Math.round(elOffset.left);\n            elOffset.right = Math.round(elOffset.right);\n        }\n        return elOffset;\n    };\n    Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n        var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n        var targetElStyles = this.getAllStyles(targetElement);\n        var targetElBCR = targetElement.getBoundingClientRect();\n        var placementPrimary = placement.split('-')[0] || 'top';\n        var placementSecondary = placement.split('-')[1] || 'center';\n        var targetElPosition = {\n            'height': targetElBCR.height || targetElement.offsetHeight,\n            'width': targetElBCR.width || targetElement.offsetWidth,\n            'top': 0,\n            'bottom': targetElBCR.height || targetElement.offsetHeight,\n            'left': 0,\n            'right': targetElBCR.width || targetElement.offsetWidth\n        };\n        switch (placementPrimary) {\n            case 'top':\n                targetElPosition.top =\n                    hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height;\n                break;\n            case 'left':\n                targetElPosition.left =\n                    hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width;\n                break;\n        }\n        switch (placementSecondary) {\n            case 'top':\n                targetElPosition.top = hostElPosition.top;\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n                break;\n            case 'left':\n                targetElPosition.left = hostElPosition.left;\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n                break;\n            case 'center':\n                if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n                    targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n                }\n                else {\n                    targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n                }\n                break;\n        }\n        targetElPosition.top = Math.round(targetElPosition.top);\n        targetElPosition.bottom = Math.round(targetElPosition.bottom);\n        targetElPosition.left = Math.round(targetElPosition.left);\n        targetElPosition.right = Math.round(targetElPosition.right);\n        return targetElPosition;\n    };\n    // get the availble placements of the target element in the viewport dependeing on the host element\n    Positioning.prototype.getAvailablePlacements = function (hostElement, targetElement) {\n        var availablePlacements = [];\n        var hostElemClientRect = hostElement.getBoundingClientRect();\n        var targetElemClientRect = targetElement.getBoundingClientRect();\n        var html = document.documentElement;\n        var windowHeight = window.innerHeight || html.clientHeight;\n        var windowWidth = window.innerWidth || html.clientWidth;\n        var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n        var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2;\n        // left: check if target width can be placed between host left and viewport start and also height of target is\n        // inside viewport\n        if (targetElemClientRect.width < hostElemClientRect.left) {\n            // check for left only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'left');\n            }\n            // check for left-top and left-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n        }\n        // top: target height is less than host top\n        if (targetElemClientRect.height < hostElemClientRect.top) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'top');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n        }\n        // right: check if target width can be placed between host right and viewport end and also height of target is\n        // inside viewport\n        if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n            // check for right only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'right');\n            }\n            // check for right-top and right-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n        }\n        // bottom: check if there is enough space between host bottom and viewport end for target height\n        if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n        }\n        return availablePlacements;\n    };\n    /**\n     * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\n     * primaryplacement: left|right\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForLeftRight = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n        }\n        if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n        }\n    };\n    /**\n     * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\n     * primaryplacement: top|bottom\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForTopBottom = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n        }\n        if (targetElemClientRect.width <= hostElemClientRect.right) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n        }\n    };\n    return Positioning;\n}());\nexport { Positioning };\nvar positionService = new Positioning();\n/*\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'left', 'right',\n *   'top-left', 'top-right',\n *   'bottom-left', 'bottom-right',\n *   'left-top', 'left-bottom',\n *   'right-top', 'right-bottom'.\n * */\nexport function positionElements(hostElement, targetElement, placement, appendToBody) {\n    var placementVals = Array.isArray(placement) ? placement : [placement];\n    // replace auto placement with other placements\n    var hasAuto = placementVals.findIndex(function (val) { return val === 'auto'; });\n    if (hasAuto >= 0) {\n        ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top',\n            'left-bottom', 'right-top', 'right-bottom',\n        ].forEach(function (obj) {\n            if (placementVals.find(function (val) { return val.search('^' + obj) !== -1; }) == null) {\n                placementVals.splice(hasAuto++, 1, obj);\n            }\n        });\n    }\n    // coordinates where to position\n    var topVal = 0, leftVal = 0;\n    var appliedPlacement;\n    // get available placements\n    var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n    var _loop_1 = function (item, index) {\n        // check if passed placement is present in the available placement or otherwise apply the last placement in the\n        // passed placement list\n        if ((availablePlacements.find(function (val) { return val === item; }) != null) || (placementVals.length === index + 1)) {\n            appliedPlacement = item;\n            var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody);\n            topVal = pos.top;\n            leftVal = pos.left;\n            return \"break\";\n        }\n    };\n    // iterate over all the passed placements\n    for (var _i = 0, _a = toItemIndexes(placementVals); _i < _a.length; _i++) {\n        var _b = _a[_i], item = _b.item, index = _b.index;\n        var state_1 = _loop_1(item, index);\n        if (state_1 === \"break\")\n            break;\n    }\n    targetElement.style.top = topVal + \"px\";\n    targetElement.style.left = leftVal + \"px\";\n    return appliedPlacement;\n}\n// function to get index and item of an array\nfunction toItemIndexes(a) {\n    return a.map(function (item, index) { return ({ item: item, index: index }); });\n}\n\n\n\n",{"version":3,"file":"D:\\Code MWSC\\2020-MWSC-Github\\webapps\\node_modules\\positioning\\dist\\positioning.js.post-build-optimizer.js","sourceRoot":"","sources":["D:\\Code MWSC\\2020-MWSC-Github\\webapps\\node_modules\\positioning\\dist\\positioning.js.pre-build-optimizer.js"],"names":[],"mappings":"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","sourcesContent":["// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\nvar Positioning = (function () {\n    function Positioning() {\n    }\n    Positioning.prototype.getAllStyles = function (element) { return window.getComputedStyle(element); };\n    Positioning.prototype.getStyle = function (element, prop) { return this.getAllStyles(element)[prop]; };\n    Positioning.prototype.isStaticPositioned = function (element) {\n        return (this.getStyle(element, 'position') || 'static') === 'static';\n    };\n    Positioning.prototype.offsetParent = function (element) {\n        var offsetParentEl = element.offsetParent || document.documentElement;\n        while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n            offsetParentEl = offsetParentEl.offsetParent;\n        }\n        return offsetParentEl || document.documentElement;\n    };\n    Positioning.prototype.position = function (element, round) {\n        if (round === void 0) { round = true; }\n        var elPosition;\n        var parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };\n        if (this.getStyle(element, 'position') === 'fixed') {\n            elPosition = element.getBoundingClientRect();\n        }\n        else {\n            var offsetParentEl = this.offsetParent(element);\n            elPosition = this.offset(element, false);\n            if (offsetParentEl !== document.documentElement) {\n                parentOffset = this.offset(offsetParentEl, false);\n            }\n            parentOffset.top += offsetParentEl.clientTop;\n            parentOffset.left += offsetParentEl.clientLeft;\n        }\n        elPosition.top -= parentOffset.top;\n        elPosition.bottom -= parentOffset.top;\n        elPosition.left -= parentOffset.left;\n        elPosition.right -= parentOffset.left;\n        if (round) {\n            elPosition.top = Math.round(elPosition.top);\n            elPosition.bottom = Math.round(elPosition.bottom);\n            elPosition.left = Math.round(elPosition.left);\n            elPosition.right = Math.round(elPosition.right);\n        }\n        return elPosition;\n    };\n    Positioning.prototype.offset = function (element, round) {\n        if (round === void 0) { round = true; }\n        var elBcr = element.getBoundingClientRect();\n        var viewportOffset = {\n            top: window.pageYOffset - document.documentElement.clientTop,\n            left: window.pageXOffset - document.documentElement.clientLeft\n        };\n        var elOffset = {\n            height: elBcr.height || element.offsetHeight,\n            width: elBcr.width || element.offsetWidth,\n            top: elBcr.top + viewportOffset.top,\n            bottom: elBcr.bottom + viewportOffset.top,\n            left: elBcr.left + viewportOffset.left,\n            right: elBcr.right + viewportOffset.left\n        };\n        if (round) {\n            elOffset.height = Math.round(elOffset.height);\n            elOffset.width = Math.round(elOffset.width);\n            elOffset.top = Math.round(elOffset.top);\n            elOffset.bottom = Math.round(elOffset.bottom);\n            elOffset.left = Math.round(elOffset.left);\n            elOffset.right = Math.round(elOffset.right);\n        }\n        return elOffset;\n    };\n    Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n        var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n        var targetElStyles = this.getAllStyles(targetElement);\n        var targetElBCR = targetElement.getBoundingClientRect();\n        var placementPrimary = placement.split('-')[0] || 'top';\n        var placementSecondary = placement.split('-')[1] || 'center';\n        var targetElPosition = {\n            'height': targetElBCR.height || targetElement.offsetHeight,\n            'width': targetElBCR.width || targetElement.offsetWidth,\n            'top': 0,\n            'bottom': targetElBCR.height || targetElement.offsetHeight,\n            'left': 0,\n            'right': targetElBCR.width || targetElement.offsetWidth\n        };\n        switch (placementPrimary) {\n            case 'top':\n                targetElPosition.top =\n                    hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height;\n                break;\n            case 'left':\n                targetElPosition.left =\n                    hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width;\n                break;\n        }\n        switch (placementSecondary) {\n            case 'top':\n                targetElPosition.top = hostElPosition.top;\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n                break;\n            case 'left':\n                targetElPosition.left = hostElPosition.left;\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n                break;\n            case 'center':\n                if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n                    targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n                }\n                else {\n                    targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n                }\n                break;\n        }\n        targetElPosition.top = Math.round(targetElPosition.top);\n        targetElPosition.bottom = Math.round(targetElPosition.bottom);\n        targetElPosition.left = Math.round(targetElPosition.left);\n        targetElPosition.right = Math.round(targetElPosition.right);\n        return targetElPosition;\n    };\n    // get the availble placements of the target element in the viewport dependeing on the host element\n    Positioning.prototype.getAvailablePlacements = function (hostElement, targetElement) {\n        var availablePlacements = [];\n        var hostElemClientRect = hostElement.getBoundingClientRect();\n        var targetElemClientRect = targetElement.getBoundingClientRect();\n        var html = document.documentElement;\n        var windowHeight = window.innerHeight || html.clientHeight;\n        var windowWidth = window.innerWidth || html.clientWidth;\n        var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n        var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2;\n        // left: check if target width can be placed between host left and viewport start and also height of target is\n        // inside viewport\n        if (targetElemClientRect.width < hostElemClientRect.left) {\n            // check for left only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'left');\n            }\n            // check for left-top and left-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n        }\n        // top: target height is less than host top\n        if (targetElemClientRect.height < hostElemClientRect.top) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'top');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n        }\n        // right: check if target width can be placed between host right and viewport end and also height of target is\n        // inside viewport\n        if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n            // check for right only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'right');\n            }\n            // check for right-top and right-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n        }\n        // bottom: check if there is enough space between host bottom and viewport end for target height\n        if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n        }\n        return availablePlacements;\n    };\n    /**\n     * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\n     * primaryplacement: left|right\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForLeftRight = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n        }\n        if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n        }\n    };\n    /**\n     * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\n     * primaryplacement: top|bottom\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForTopBottom = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n        }\n        if (targetElemClientRect.width <= hostElemClientRect.right) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n        }\n    };\n    return Positioning;\n}());\nexport { Positioning };\nvar positionService = new Positioning();\n/*\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'left', 'right',\n *   'top-left', 'top-right',\n *   'bottom-left', 'bottom-right',\n *   'left-top', 'left-bottom',\n *   'right-top', 'right-bottom'.\n * */\nexport function positionElements(hostElement, targetElement, placement, appendToBody) {\n    var placementVals = Array.isArray(placement) ? placement : [placement];\n    // replace auto placement with other placements\n    var hasAuto = placementVals.findIndex(function (val) { return val === 'auto'; });\n    if (hasAuto >= 0) {\n        ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top',\n            'left-bottom', 'right-top', 'right-bottom',\n        ].forEach(function (obj) {\n            if (placementVals.find(function (val) { return val.search('^' + obj) !== -1; }) == null) {\n                placementVals.splice(hasAuto++, 1, obj);\n            }\n        });\n    }\n    // coordinates where to position\n    var topVal = 0, leftVal = 0;\n    var appliedPlacement;\n    // get available placements\n    var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n    var _loop_1 = function (item, index) {\n        // check if passed placement is present in the available placement or otherwise apply the last placement in the\n        // passed placement list\n        if ((availablePlacements.find(function (val) { return val === item; }) != null) || (placementVals.length === index + 1)) {\n            appliedPlacement = item;\n            var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody);\n            topVal = pos.top;\n            leftVal = pos.left;\n            return \"break\";\n        }\n    };\n    // iterate over all the passed placements\n    for (var _i = 0, _a = toItemIndexes(placementVals); _i < _a.length; _i++) {\n        var _b = _a[_i], item = _b.item, index = _b.index;\n        var state_1 = _loop_1(item, index);\n        if (state_1 === \"break\")\n            break;\n    }\n    targetElement.style.top = topVal + \"px\";\n    targetElement.style.left = leftVal + \"px\";\n    return appliedPlacement;\n}\n// function to get index and item of an array\nfunction toItemIndexes(a) {\n    return a.map(function (item, index) { return ({ item: item, index: index }); });\n}\n//# sourceMappingURL=positioning.js.map"]}]}